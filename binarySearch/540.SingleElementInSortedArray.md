# Problem Statement
You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.

Return the single element that appears only once.

Your solution must run in O(log n) time and O(1) space.

Example 1:

Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
Example 2:

Input: nums = [3,3,7,7,10,11,11]
Output: 10

**brute force:**

```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        for i in range(n):
            if(i == 0):
                if(nums[i] != nums[i+1]):
                    return nums[i]
            elif(i == n-1):
                if(nums[i] != nums[i-1]):
                    return nums[i]
            else:
                if(nums[i]!=nums[i-1] and nums[i]!=nums[i+1]):
                    return nums[i]
        
        return -1
            
```
tc : O(n)
sc : O(1)

**optimal apporach:**

1. here i can find a pattern where the elements on left of the single element are in (even, odd) and on the right half the elements are in the
(odd, even)
2. once i find the mid element with binary search, i will find a way to elminate to the side which doesnt have the single element. 
i can follow the even, odd apporach. 

```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int n = nums.size();

        if(n == 1){
            return nums[0];
        }
        if(nums[0] != nums[1]){
            return nums[0];
        }
        if(nums[n-1] != nums[n-2]){
            return nums[n-1];
        }

        int low = 1, high = n - 2;
        while(low <= high){
            int mid = low + (high - low) / 2;

            if(nums[mid] != nums[mid - 1] && nums[mid]!= nums[mid+1]){
                return nums[mid];
            
            }
            //(even, odd) -> elminate left half
            else if((mid % 2 == 1 && nums[mid] == nums[mid - 1]) || (mid % 2 == 0 && nums[mid] == nums[mid+1])){
                low = mid + 1;
            }else{ //(odd, even) -> elminate right half
                high = mid - 1;
            } 
        }
        return - 1;
    }
};
```
tc : O(logn)
sc : O(1)

